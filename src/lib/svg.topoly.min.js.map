{"version":3,"file":"svg.topoly.min.js","sources":["../src/svg.topoly.js"],"sourcesContent":["import {\n  Path,\n  PathArray,\n  PointArray,\n  Polygon,\n  Polyline,\n  Number as SVGNumber,\n  extend,\n  parser\n} from '@svgdotjs/svg.js'\n\n// Normalise attributes\nconst normaliseAttributes = (attr) => {\r\n  for (var a in attr) {\n    if (!/fill|stroke|opacity|transform/.test(a)) { delete attr[a] }\n  }\r\n\r\n  return attr\r\n}\r\n\r\nconst getParserPath = (pathArray) => {\r\n  const path = parser().path\r\n  path.setAttribute('d', pathArray.toString())\r\n  return path\r\n}\r\n\r\nconst pathLength = (pathArray) => {\r\n  return getParserPath(pathArray).getTotalLength()\r\n}\r\n\r\nextend(PathArray, {\r\n  // Convert path to poly\r\n  toPoly (sample = '1%') {\r\n    let points = []\r\n    let length = 0\r\n    let x = 0\r\n    let y = 0\r\n\r\n    // parse sample value\r\n    sample = new SVGNumber(sample)\r\n\r\n    // get total length\r\n    const total = pathLength(this)\r\n\r\n    let distance\r\n\r\n    // calculate sample distance\r\n    if (sample.unit === '%') {\r\n      // sample distance in %\r\n      distance = total * sample.value\r\n    } else if (sample.unit === 'px') {\r\n      // fixed sample distance in px\r\n      distance = sample.value\r\n    } else {\r\n      // specific number of samples\r\n      distance = total / sample.value\r\n    }\r\n\r\n    // prepare arrays\r\n    const segmentsQueue = this.slice()\r\n\r\n    // prepare helpers functions\r\n    const addPoint = function (px, py) {\r\n      // get last point\r\n      const lastPoint = points[points.length - 1]\r\n\r\n      // when the last point doesn't equal the current point add the current point\r\n      if (!lastPoint || px !== lastPoint[0] || py !== lastPoint[1]) {\r\n        points.push([px, py])\r\n        x = px\r\n        y = py\r\n      }\r\n    }\r\n\r\n    const addSegmentPoint = function (segment) {\r\n      // don't bother processing path ends\r\n      if (segment[0] === 'Z') return\r\n\r\n      // map segment to x and y\r\n      switch (segment[0]) {\r\n      case 'M':\r\n      case 'L':\r\n      case 'T':\r\n        x = segment[1]\r\n        y = segment[2]\r\n        break\r\n      case 'H':\r\n        x = segment[1]\r\n        break\r\n      case 'V':\r\n        y = segment[1]\r\n        break\r\n      case 'C':\r\n        x = segment[5]\r\n        y = segment[6]\r\n        break\r\n      case 'S':\r\n      case 'Q':\r\n        x = segment[3]\r\n        y = segment[4]\r\n        break\r\n      case 'A':\r\n        x = segment[6]\r\n        y = segment[7]\r\n        break\r\n      }\r\n\r\n      // add point\r\n      addPoint(x, y)\r\n    }\r\n\r\n    let lastSegment\r\n    let segmentIndex = 0\r\n    let subPath = this.slice(0, segmentIndex + 1)\r\n    let subPathLength = pathLength(subPath)\r\n\r\n    // sample through path\r\n    while (length < total) {\r\n\r\n      // get segment index\r\n      while (subPathLength < length) {\r\n        ++segmentIndex\r\n        subPath = this.slice(0, segmentIndex + 1)\r\n        subPathLength = pathLength(subPath)\r\n      }\r\n\r\n      // get segment\r\n      const segment = this[segmentIndex]\r\n\r\n      // new segment?\r\n      if (segment !== lastSegment) {\r\n        // add the segment we just left\r\n        if (lastSegment !== undefined) {\r\n          addSegmentPoint(lastSegment)\r\n        }\r\n\r\n        // add all segments which we just skipped\r\n        while (segmentsQueue.length && segmentsQueue[0] !== segment) {\r\n          addSegmentPoint(segmentsQueue.shift())\r\n        }\r\n\r\n        lastSegment = segment\r\n      }\r\n\r\n      // add points in between when curving\r\n      switch (segment[0]) {\r\n      case 'C':\r\n      case 'T':\r\n      case 'S':\r\n      case 'Q':\r\n      case 'A':\r\n        const point = getParserPath(this).getPointAtLength(length)\r\n        addPoint(point.x, point.y)\r\n        break\r\n      }\r\n\r\n      // increment by sample value\r\n      length += distance\r\n    }\r\n\r\n    let i = 0\r\n    let il = segmentsQueue.length\r\n    // add remaining segments we didn't pass while sampling\r\n    for (; i < il; ++i) {\r\n      addSegmentPoint(segmentsQueue[i])\r\n    }\r\n\r\n    // send out as point array\r\n    return new PointArray(points)\r\n  }\r\n\r\n})\r\n\r\nextend(Path, {\r\n  // Convert path to poly\r\n  toPoly (sample = '1%', replace = true) {\r\n    // define type\r\n    const Poly = /z\\s*$/i.test(this.attr('d')) ? Polygon : Polyline\r\n\r\n    const pointArray = this.array().toPoly(sample)\r\n\r\n    // create poly\r\n    const poly = new Poly().plot(pointArray)\r\n      .attr(normaliseAttributes(this.attr()))\r\n\r\n    // insert poly\r\n    if (replace) {\r\n      this.replace(poly)\r\n    }\r\n\r\n    return poly\r\n  }\r\n\r\n})\r\n"],"names":["getParserPath","pathArray","path","parser","setAttribute","toString","pathLength","getTotalLength","PathArray","toPoly","sample","points","length","x","y","SVGNumber","distance","total","this","unit","value","lastSegment","segmentsQueue","slice","addPoint","px","py","lastPoint","push","addSegmentPoint","segment","segmentIndex","subPath","subPathLength","undefined","shift","point","getPointAtLength","i","il","PointArray","Path","replace","Poly","test","attr","Polygon","Polyline","pointArray","array","poly","plot","a","normaliseAttributes"],"mappings":";0BAYA,IAQMA,EAAgB,SAACC,OACfC,EAAOC,WAASD,YACtBA,EAAKE,aAAa,IAAKH,EAAUI,YAC1BH,GAGHI,EAAa,SAACL,UACXD,EAAcC,GAAWM,2BAG3BC,YAAW,CAEhBC,sBAAQC,yDAAS,KACXC,EAAS,GACTC,EAAS,EACTC,EAAI,EACJC,EAAI,EAGRJ,EAAS,IAAIK,SAAUL,OAKnBM,EAFEC,EAAQX,EAAWY,MAOvBF,EAFkB,MAAhBN,EAAOS,KAEEF,EAAQP,EAAOU,MACD,OAAhBV,EAAOS,KAELT,EAAOU,MAGPH,EAAQP,EAAOU,cAwDxBC,EApDEC,EAAgBJ,KAAKK,QAGrBC,EAAW,SAAUC,EAAIC,OAEvBC,EAAYhB,EAAOA,EAAOC,OAAS,GAGpCe,GAAaF,IAAOE,EAAU,IAAMD,IAAOC,EAAU,KACxDhB,EAAOiB,KAAK,CAACH,EAAIC,IACjBb,EAAIY,EACJX,EAAIY,IAIFG,EAAkB,SAAUC,MAEb,MAAfA,EAAQ,WAGJA,EAAQ,QACX,QACA,QACA,IACHjB,EAAIiB,EAAQ,GACZhB,EAAIgB,EAAQ,aAET,IACHjB,EAAIiB,EAAQ,aAET,IACHhB,EAAIgB,EAAQ,aAET,IACHjB,EAAIiB,EAAQ,GACZhB,EAAIgB,EAAQ,aAET,QACA,IACHjB,EAAIiB,EAAQ,GACZhB,EAAIgB,EAAQ,aAET,IACHjB,EAAIiB,EAAQ,GACZhB,EAAIgB,EAAQ,GAKdN,EAASX,EAAGC,KAIViB,EAAe,EACfC,EAAUd,KAAKK,MAAM,EAAGQ,EAAe,GACvCE,EAAgB3B,EAAW0B,GAGxBpB,EAASK,GAAO,MAGdgB,EAAgBrB,KACnBmB,EACFC,EAAUd,KAAKK,MAAM,EAAGQ,EAAe,GACvCE,EAAgB3B,EAAW0B,OAIvBF,EAAUZ,KAAKa,MAGjBD,IAAYT,EAAa,UAEPa,IAAhBb,GACFQ,EAAgBR,GAIXC,EAAcV,QAAUU,EAAc,KAAOQ,GAClDD,EAAgBP,EAAca,SAGhCd,EAAcS,SAIRA,EAAQ,QACX,QACA,QACA,QACA,QACA,QACGM,EAAQpC,EAAckB,MAAMmB,iBAAiBzB,GACnDY,EAASY,EAAMvB,EAAGuB,EAAMtB,GAK1BF,GAAUI,UAGRsB,EAAI,EACJC,EAAKjB,EAAcV,OAEhB0B,EAAIC,IAAMD,EACfT,EAAgBP,EAAcgB,WAIzB,IAAIE,aAAW7B,eAKnB8B,OAAM,CAEXhC,sBAAQC,yDAAS,KAAMgC,6DAEfC,EAAO,SAASC,KAAK1B,KAAK2B,KAAK,MAAQC,UAAUC,WAEjDC,EAAa9B,KAAK+B,QAAQxC,OAAOC,GAGjCwC,GAAO,IAAIP,GAAOQ,KAAKH,GAC1BH,KA3KqB,SAACA,OACtB,IAAIO,KAAKP,EACP,gCAAgCD,KAAKQ,WAAaP,EAAKO,UAGvDP,EAsKGQ,CAAoBnC,KAAK2B,gBAG7BH,QACGA,QAAQQ,GAGRA"}